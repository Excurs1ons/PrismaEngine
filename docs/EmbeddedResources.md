# 内嵌资源压缩系统

## 概述

PrismaEngine 采用**声明式资源系统**管理内嵌资源，类似 Unreal Engine 的 `LOCTEXT`、C# 的 `.resx`、Qt 的 `.qrc`。

**特点**：
- 声明式：在一个文件中集中管理所有内嵌资源
- 编译时压缩：使用 Snappy 压缩，减小二进制大小
- 按需解压：首次访问时才解压，避免启动时一次性解压所有资源
- 异步加载：支持后台预加载，配合启动画面使用

## 快速开始

### 1. 声明资源

```cpp
// assets/embedded_resources.decl
#pragma once

// 字符串资源 (着色器、脚本、配置等)
PRISMA_EMBED_STRING(DefaultVertexShader, "assets/shaders/default.vert")
PRISMA_EMBED_STRING(DefaultFragShader, "assets/shaders/default.frag")

// 字节数组资源 (字体、纹理、模型等)
PRISMA_EMBED_BYTES(DefaultFont, "assets/fonts/Default.ttf")
PRISMA_EMBED_BYTES(IconTexture, "assets/textures/icon.png")
```

### 2. 使用资源

```cpp
#include "engine/core/EmbeddedResources.h"

void Game::initialize() {
    // 获取着色器字符串
    auto vertShader = PRISMA_GET_STRING(DefaultVertexShader);
    auto fragShader = PRISMA_GET_STRING(DefaultFragShader);
    m_defaultShader = Renderer::createShader(vertShader, fragShader);

    // 获取字体数据
    auto fontData = PRISMA_GET_RESOURCE(DefaultFont);
    m_defaultFont = Font::loadFromMemory(fontData);
}
```

## 文件结构

```
PrismaEngine/
├── assets/
│   ├── embedded_resources.decl           # 资源声明文件
│   ├── shaders/                          # 原始资源文件
│   │   ├── default.vert
│   │   └── default.frag
│   ├── fonts/
│   │   └── Default.ttf
│   └── textures/
│       └── icon.png
├── engine/core/
│   ├── EmbeddedResources.h               # 运行时 API 头文件
│   └── EmbeddedResources.cpp             # 运行时实现
├── tools/compress/
│   └── generate_embedded.py              # 代码生成器
└── build/
    └── embedded_resources_gen.h          # 自动生成的压缩资源
```

## 详细说明

### 资源声明文件 (.decl)

```cpp
// assets/embedded_resources.decl
#pragma once

// 字符串资源 - 用于着色器、脚本、配置文件等
PRISMA_EMBED_STRING(DefaultVertexShader, "assets/shaders/default.vert")
PRISMA_EMBED_STRING(DefaultFragShader, "assets/shaders/default.frag")
PRISMA_EMBED_STRING(UIShader, "assets/shaders/ui.vert")
PRISMA_EMBED_STRING(PostProcessShader, "assets/shaders/postprocess.frag")
PRISMA_EMBED_STRING(ConfigJSON, "assets/config.json")

// 字节数组资源 - 用于字体、纹理、音频、模型等
PRISMA_EMBED_BYTES(DefaultFont, "assets/fonts/Default.ttf")
PRISMA_EMBED_BYTES(IconTexture, "assets/textures/icon.png")
PRISMA_EMBED_BYTES(StartupMusic, "assets/audio/startup.ogg")
PRISMA_EMBED_BYTES(Cursor, "assets/textures/cursor.dds")
```

### 宏定义头文件

```cpp
// engine/core/EmbeddedResources.h
#pragma once

#if defined(PRISMA_GENERATING_EMBEDDED)
    // 声明宏（空实现，仅用于工具解析）
    #define PRISMA_EMBED_STRING(NAME, PATH)
    #define PRISMA_EMBED_BYTES(NAME, PATH)
#else
    // 实际使用时引用生成的资源
    #include "embedded_resources_gen.h"

    namespace Engine::Embedded {
        class ResourceCache;
    }
#endif
```

### 代码生成器

```python
# tools/compress/generate_embedded.py
#!/usr/bin/env python3
"""
PrismaEngine 内嵌资源代码生成器
用法: generate_embedded.py <decl_file> <base_dir> <output_file>

依赖: pip install python-snappy
"""
import re
import sys
import snappy
from pathlib import Path
from dataclasses import dataclass
from typing import List

@dataclass
class Resource:
    name: str
    path: str
    type: str  # 'string' or 'bytes'

def parse_decl_file(decl_file: Path) -> List[Resource]:
    """解析 .decl 声明文件"""
    content = decl_file.read_text()
    resources = []

    # 匹配 PRISMA_EMBED_STRING(NAME, "path")
    for match in re.finditer(r'PRISMA_EMBED_STRING\((\w+),\s*"([^"]+)"\)', content):
        resources.append(Resource(match.group(1), match.group(2), 'string'))

    # 匹配 PRISMA_EMBED_BYTES(NAME, "path")
    for match in re.finditer(r'PRISMA_EMBED_BYTES\((\w+),\s*"([^"]+)"\)', content):
        resources.append(Resource(match.group(1), match.group(2), 'bytes'))

    return resources

def format_byte_array(data: bytes, indent: str = "    ") -> List[str]:
    """格式化字节数组，每行 16 字节"""
    lines = []
    for i in range(0, len(data), 16):
        chunk = data[i:i+16]
        hex_values = ', '.join(f'0x{b:02x}' for b in chunk)
        if i + 16 < len(data):
            hex_values += ','
        lines.append(f'{indent}{hex_values}')
    return lines

def generate_header(resources: List[Resource], base_dir: Path) -> str:
    """生成压缩资源头文件"""
    lines = [
        "// Auto-generated by generate_embedded.py - do not edit",
        "// Usage: PRISMA_EMBED_STRING/PRISMA_EMBED_BYTES in .decl file",
        "",
        "#pragma once",
        "",
        "#include <cstdint>",
        "#include <cstddef>",
        "",
        "namespace Engine::Embedded {",
        ""
    ]

    # 生成每个资源的压缩数据
    for res in resources:
        source_path = base_dir / res.path

        if not source_path.exists():
            lines.append(f"// ERROR: {res.path} not found!")
            lines.append(f"constexpr uint8_t {res.name}[] = {{}};")
            lines.append(f"constexpr size_t {res.name}_Size = 0;")
            lines.append(f"constexpr size_t {res.name}_OriginalSize = 0;")
            lines.append("")
            continue

        data = source_path.read_bytes()
        compressed = snappy.compress(data)
        ratio = len(data) / len(compressed) if len(compressed) > 0 else 0

        lines.append(f"// {res.path}")
        lines.append(f"// Original: {len(data)} bytes, Compressed: {len(compressed)} bytes ({ratio:.1f}x)")

        # 字节数组
        lines.append(f"constexpr uint8_t {res.name}[] = {{")
        lines.extend(format_byte_array(compressed))
        lines.append("};")
        lines.append(f"constexpr size_t {res.name}_Size = sizeof({res.name});")
        lines.append(f"constexpr size_t {res.name}_OriginalSize = {len(data)};")
        lines.append("")

    # 生成资源查找表
    lines.append("// Resource lookup table")
    lines.append("struct ResourceEntry {")
    lines.append("    const char* name;")
    lines.append("    const uint8_t* data;")
    lines.append("    size_t compressedSize;")
    lines.append("    size_t originalSize;")
    lines.append("};")
    lines.append("")
    lines.append("constexpr ResourceEntry s_resources[] = {")

    for res in resources:
        lines.append(f"    {{ \"{res.name}\", {res.name}, {res.name}_Size, {res.name}_OriginalSize }},")

    lines.append("};")
    lines.append("")
    lines.append("} // namespace Engine::Embedded")

    return '\n'.join(lines)

def main():
    if len(sys.argv) != 4:
        print("Usage: generate_embedded.py <decl_file> <base_dir> <output_file>")
        print(f"\nExample: {sys.argv[0]} assets/embedded_resources.decl . build/embedded_resources_gen.h")
        sys.exit(1)

    decl_file = Path(sys.argv[1])
    base_dir = Path(sys.argv[2])
    output_file = Path(sys.argv[3])

    resources = parse_decl_file(decl_file)
    header_content = generate_header(resources, base_dir)

    # 确保输出目录存在
    output_file.parent.mkdir(parents=True, exist_ok=True)
    output_file.write_text(header_content)

    # 打印统计信息
    total_original = sum((base_dir / r.path).stat().st_size for r in resources
                         if (base_dir / r.path).exists())
    total_compressed = sum(len(snappy.compress((base_dir / r.path).read_bytes()))
                           for r in resources if (base_dir / r.path).exists())
    print(f"Generated {output_file} with {len(resources)} resources")
    print(f"  Original:   ~{total_original//1024} KB")
    print(f"  Compressed: ~{total_compressed//1024} KB ({total_original/total_compressed:.1f}x ratio)")

if __name__ == '__main__':
    main()
```

### 运行时 API

```cpp
// engine/core/EmbeddedResources.cpp
#include "EmbeddedResources.h"
#include "Compress/SnappyCompression.h"
#include <mutex>
#include <unordered_map>
#include <span>

namespace Engine::Embedded {

class ResourceCache {
public:
    // 同步获取（首次调用会解压并缓存）
    static std::span<const uint8_t> get(std::string_view name) {
        std::lock_guard lock(s_mutex);

        // 检查缓存
        auto it = s_decompressedCache.find(std::string(name));
        if (it != s_decompressedCache.end()) {
            return it->second;
        }

        // 查找资源条目
        const ResourceEntry* entry = findResource(name);
        if (!entry) {
            return {};
        }

        // 解压并缓存
        std::vector<uint8_t> decompressed = Compress::SnappyCompression::decompress(
            entry->data, entry->compressedSize);
        decompressed.resize(entry->originalSize);  // 确保大小正确

        s_decompressedCache[std::string(name)] = std::move(decompressed);
        return s_decompressedCache[std::string(name)];
    }

    // 获取字符串（用于着色器等文本资源）
    static std::string_view getString(std::string_view name) {
        auto data = get(name);
        return std::string_view(reinterpret_cast<const char*>(data.data()), data.size());
    }

    // 异步预加载
    static void preloadAsync(std::string_view name) {
        JobSystem::submit([name = std::string(name)]() {
            get(name);
        });
    }

    // 批量预加载（带进度回调）
    static void preloadBatch(std::span<const std::string> names,
                            std::function<void(size_t, size_t)> progress) {
        for (size_t i = 0; i < names.size(); ++i) {
            preloadAsync(names[i]);
            if (progress) progress(i + 1, names.size());
        }
    }

    // 检查资源是否已缓存
    static bool isCached(std::string_view name) {
        std::lock_guard lock(s_mutex);
        return s_decompressedCache.contains(std::string(name));
    }

    // 预加载完成检查（用于同步等待）
    static void waitUntilCached(std::string_view name) {
        while (!isCached(name)) {
            std::this_thread::yield();
        }
    }

private:
    static const ResourceEntry* findResource(std::string_view name) {
        for (const auto& entry : s_resources) {
            if (name == entry.name) {
                return &entry;
            }
        }
        return nullptr;
    }

    inline static std::unordered_map<std::string, std::vector<uint8_t>> s_decompressedCache;
    inline static std::mutex s_mutex;
};

// 便捷访问宏
#define PRISMA_GET_RESOURCE(name) ::Engine::Embedded::ResourceCache::get(#name)
#define PRISMA_GET_STRING(name)  ::Engine::Embedded::ResourceCache::getString(#name)

} // namespace Engine::Embedded
```

### CMake 集成

```cmake
# ================================================================
# 内嵌资源压缩系统
# ================================================================

# 查找 Python3
find_package(Python3 COMPONENTS Interpreter REQUIRED)

# 资源声明文件
set(EMBEDDED_DECL_FILE ${CMAKE_SOURCE_DIR}/assets/embedded_resources.decl)

# 生成的头文件路径
set(EMBEDDED_GEN_FILE ${CMAKE_CURRENT_BINARY_DIR}/embedded_resources_gen.h)

# 代码生成命令
add_custom_command(
    OUTPUT ${EMBEDDED_GEN_FILE}
    COMMAND ${Python3_EXECUTABLE}
        ${CMAKE_SOURCE_DIR}/tools/compress/generate_embedded.py
        ${EMBEDDED_DECL_FILE}
        ${CMAKE_SOURCE_DIR}
        ${EMBEDDED_GEN_FILE}
    DEPENDS ${EMBEDDED_DECL_FILE}
    COMMENT "Generating embedded resources (compressed with Snappy)"
    VERBATIM
)

# 自定义目标，方便手动触发
add_custom_target(generate_embedded_resources
    DEPENDS ${EMBEDDED_GEN_FILE}
)

# 确保引擎构建前生成资源
add_dependencies(Engine generate_embedded_resources)

# 添加到 include 路径
target_include_directories(Engine PRIVATE ${CMAKE_CURRENT_BINARY_DIR})

# 可选：添加到 IDE 项目（便于查看生成的文件）
if(MSVC OR XCODE)
    target_sources(Engine PRIVATE ${EMBEDDED_GEN_FILE})
    set_source_files_properties(${EMBEDDED_GEN_FILE} PROPERTIES
        GENERATED TRUE
        HEADER_FILE TRUE
    )
endif()
```

## 使用示例

### 基础使用

```cpp
#include "engine/core/EmbeddedResources.h"

void Game::initialize() {
    // 获取着色器字符串
    auto vertShader = PRISMA_GET_STRING(DefaultVertexShader);
    auto fragShader = PRISMA_GET_STRING(DefaultFragShader);
    m_defaultShader = Renderer::createShader(vertShader, fragShader);

    // 获取字体数据
    auto fontData = PRISMA_GET_RESOURCE(DefaultFont);
    m_defaultFont = Font::loadFromMemory(fontData);

    // 获取配置
    auto configJson = PRISMA_GET_STRING(ConfigJSON);
    m_config = nlohmann::json::parse(configJson);
}
```

### 启动画面预加载

```cpp
class LoadingScreen : public Scene {
public:
    void onEnter() override {
        showLoadingBar();

        // 预加载核心资源（异步，显示进度）
        const std::string resources[] = {
            "DefaultFont",
            "DefaultVertexShader",
            "DefaultFragShader",
            "IconTexture",
            "ConfigJSON"
        };

        Embedded::ResourceCache::preloadBatch(resources,
            [&](size_t current, size_t total) {
                updateLoadingBar(float(current) / total);
            });

        // 等待预加载完成
        for (const auto& name : resources) {
            Embedded::ResourceCache::waitUntilCached(name);
        }

        SceneManager::loadScene<MainMenu>();
    }
};
```

### 按场景加载

```cpp
class GameScene : public Scene {
public:
    void onEnter() override {
        // 只预加载本场景需要的资源
        Embedded::ResourceCache::preloadAsync("Level1Mesh");
        Embedded::ResourceCache::preloadAsync("Level1Textures");

        // 玩家进入某个区域时才加载该区域资源
        m_regionLoadTrigger = [this](const Rect& region) {
            if (region.contains(playerPosition())) {
                Embedded::ResourceCache::preloadAsync(region.shaderName);
            }
        };
    }
};
```

## 压缩效果

| 资源类型 | 原始大小 | 压缩后 | 节省 | 解压时间 |
|----------|----------|--------|------|----------|
| 着色器 GLSL (20KB) | 20 KB | 8 KB | 60% | <0.1ms |
| SPIR-V 着色器 (50KB) | 50 KB | 32 KB | 36% | <0.1ms |
| TrueType 字体 (500KB) | 500 KB | 280 KB | 44% | ~1ms |
| PNG 图标 (10KB) | 10 KB | 9 KB | 10% | <0.1ms |
| JSON 配置 (5KB) | 5 KB | 2 KB | 60% | <0.1ms |

## 启动画面时间分配

```
┌─────────────────────────────────────────────────┐
│  Loading Screen (3-5 seconds)                  │
├─────────────────────────────────────────────────┤
│  ▓▓▓▓▓▓▓▓▓░░░░░░ 60%                         │
│  Loading assets...                             │
├─────────────────────────────────────────────────┤
│  解压系统资源 (0.5s)    ← Snappy 很快          │
│  加载着色器 (0.3s)                                │
│  加载纹理 (1.5s)        ← 磁盘 I/O 是瓶颈       │
│  解压纹理 (0.5s)                                │
│  初始化场景 (0.2s)                              │
│  预留缓冲 (1s)                                  │
└─────────────────────────────────────────────────┘
```

**关键点**：
- 启动画面的主要目的是掩盖**磁盘/网络 I/O**，而非解压时间
- Snappy 解压非常快（~500MB/s），通常不是瓶颈
- 真正的耗时操作是：纹理上传GPU、着色器编译、网络请求
- 按需解压避免启动时一次性解压所有资源
- 异步预加载让用户体验更流畅

## 与其他引擎的类比

| 引擎/框架 | 机制 | 文件类型 | 生成内容 |
|-----------|------|----------|----------|
| **Unreal Engine** | `LOCTEXT("Key", "Text")` | `.manifest` | `.locres` |
| **Unity** | `.resx` 编辑器 | `.resx` | `.resource.cs` |
| **Qt** | `<file>` in `.qrc` | `.qrc` | `qrc_*.cpp` |
| **C# / .NET** | `.resx` 文件 | `.resx` | `.Resources` 类 |
| **PrismaEngine** | `PRISMA_EMBED_*` 宏 | `.decl` | `_gen.h` |

## API 参考

### 宏

| 宏 | 说明 |
|-----|------|
| `PRISMA_EMBED_STRING(NAME, PATH)` | 声明字符串资源 |
| `PRISMA_EMBED_BYTES(NAME, PATH)` | 声明字节数组资源 |
| `PRISMA_GET_RESOURCE(name)` | 获取字节数组资源（自动解压） |
| `PRISMA_GET_STRING(name)` | 获取字符串资源（自动解压） |

### ResourceCache 类

| 方法 | 说明 |
|------|------|
| `get(name)` | 获取资源字节数据（首次访问自动解压） |
| `getString(name)` | 获取资源字符串（首次访问自动解压） |
| `preloadAsync(name)` | 异步预加载资源 |
| `preloadBatch(names, progress)` | 批量异步预加载 |
| `isCached(name)` | 检查资源是否已缓存 |
| `waitUntilCached(name)` | 等待资源预加载完成 |

## 依赖

- Python 3.7+
- python-snappy (`pip install python-snappy`)
- CMake 3.31+
